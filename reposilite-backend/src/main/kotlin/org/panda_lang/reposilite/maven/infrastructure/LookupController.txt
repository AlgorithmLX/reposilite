    /** Lookup Controller


    OpenApi(
        route = "xD"
        operationId = "repositoryLookup",
        summary = "Browse the contents of repositories",
        description = "The route may return various responses to properly handle Maven specification and frontend application using the same path.",
        tags = ["Repository"],
        pathParams = [OpenApiParam(
            name = "*",
            description = "Artifact path qualifier",
            required = true,
            allowEmptyValue = true
        ), OpenApiParam(
            name = "*/latest",
    description = "[Optional] Artifact path qualifier with /latest at the end returns latest version of artifact as text/plain"
    )],
    responses = [OpenApiResponse(
    status = "200",
    description = "Input stream of requested file",
    content = [OpenApiContent(type = FORM_DATA_MULTIPART)]
    ), OpenApiResponse(
    status = "404",
    description = "Returns 404 (for Maven) with frontend (for user) as a response if requested resource is not located in the current repository"
    )]
    )
    override fun handle(ctx: Context) = context(contextFactory, ctx) {
        context.getLogger().debug("LOOKUP " + context.uri().toString() + " from " + context.address())

        val response: Result<LookupResponse, ErrorResponse>
        if (lookupService.exists(context)) {
            response = try {
                lookupService.find(context)
            } catch (e: IOException) {
                e.printStackTrace()
                return
            }
        } else if (hasProxied) {
            response = proxyService.findProxied(context)
        } else {
            response = Result.error<LookupResponse, ErrorResponse>(ErrorResponse(HttpStatus.SC_NOT_FOUND, "File not found"))
        }
        handleResult(ctx, context, response)
    }

    private fun handleResult(ctx: Context, context: ReposiliteContext, result: Result<LookupResponse, ErrorResponse>) {
        result
            .peek(Consumer<LookupResponse> { response: LookupResponse? -> handleResult(ctx, context, response) })
            .onError(Consumer<ErrorResponse> { error: ErrorResponse -> handleError(ctx, error) })
    }

    private fun handleResult(ctx: Context, context: ReposiliteContext, response: LookupResponse) {
        response.getFileDetails().peek { details ->
            if (details.getContentLength() > 0) {
                ctx.res.setContentLengthLong(details.getContentLength())
            }
            if (response.isAttachment()) {
                ctx.res.setHeader("Content-Disposition", "attachment; filename=\"" + details.getName().toString() + "\"")
            }
        }
        response.getContentType().peek { type: String? -> ctx.res.contentType = type }
        response.getValue().peek(ctx::result)
        context.result().peek { result ->
            try {
                if (OutputUtils.isProbablyOpen(ctx.res.outputStream)) {
                    result.accept(ctx.res.outputStream)
                }
            } catch (exception: IOException) {
                failureService.throwException(context.uri(), exception)
            }
        }
    }

    private fun handleError(ctx: Context, error: ErrorResponse) {
        ctx.result(frontend.forMessage(error.message))
            .status(error.status)
            .contentType("text/html").res.setCharacterEncoding("UTF-8")
    }

    **/